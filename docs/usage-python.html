

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Use ProtParCon in Python &mdash; ProtParCon 2.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Using ProtParCon in terminal" href="usage-shell.html" />
    <link rel="prev" title="Install ProtParCon" href="install.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> ProtParCon
          

          
          </a>

          
            
            
              <div class="version">
                2.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Knowing ProtParCon</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">ProtParCon at a glance</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html#work-flow-of-protparcon">Work-Flow of ProtParCon</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html#walk-through-of-an-example">Walk-through of an example</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html#what-just-happened">What just happened?</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html#what-else">What else?</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html#what-s-next">What’s next?</a></li>
</ul>
<p class="caption"><span class="caption-text">Installing ProtParCon</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Install ProtParCon</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html#install-protparcon-to-a-virtual-environment-recommended">Install ProtParCon to a virtual environment (recommended)</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html#things-that-are-good-to-know">Things that are good to know</a></li>
</ul>
<p class="caption"><span class="caption-text">Using ProtParCon</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Use ProtParCon in Python</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#import-protparcon">Import ProtParCon</a></li>
<li class="toctree-l2"><a class="reference internal" href="#align-multiple-sequences">Align multiple sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="#infer-maximum-likelihood-tree">Infer Maximum-Likelihood tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reconstruct-ancestral-states">Reconstruct ancestral states</a></li>
<li class="toctree-l2"><a class="reference internal" href="#simulate-protein-sequences">Simulate protein sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="#topology-test">Topology test</a></li>
<li class="toctree-l2"><a class="reference internal" href="#identify-molecular-convergence-in-proteins">Identify molecular convergence in proteins</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="usage-shell.html">Using ProtParCon in terminal</a><ul>
<li class="toctree-l2"><a class="reference internal" href="usage-shell.html#check-protparcon-command-line-toolsets">Check ProtParCon command-line toolsets</a></li>
<li class="toctree-l2"><a class="reference internal" href="usage-shell.html#using-toolsets-in-terminal">Using toolsets in terminal</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Extending ProtParCon</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-ProtParCon.msa">msa</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-ProtParCon.asr">asr</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-ProtParCon.imc">imc</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-ProtParCon.sim">sim</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-ProtParCon.aut">aut</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-ProtParCon.mlt">mlt</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#utilities">utilities</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ProtParCon</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Use ProtParCon in Python</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/usage-python.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p id="intro-usage-python">The best way to learn is with examples, and ProtParCon is no exception. For this
reason, the following sections describe some pre-made examples of how to
use ProtParCon to manipulate molecular sequence data and identify molecular
convergences.</p>
<p>Since ProtParCon is written in pure Python, you can use ProtParCon in any Python script
or interactive Python session. Meanwhile, ProtParCon also ships a command-line
toolset to you, you are able to use the command-line tools in a terminal.
We will show you examples of using ProtParCon in Python and terminal separately.</p>
<div class="section" id="use-protparcon-in-python">
<h1>Use ProtParCon in Python<a class="headerlink" href="#use-protparcon-in-python" title="Permalink to this headline">¶</a></h1>
<div class="section" id="import-protparcon">
<h2>Import ProtParCon<a class="headerlink" href="#import-protparcon" title="Permalink to this headline">¶</a></h2>
<p>You can import ProtParCon as a module or directly import general use functions
inside the module, thus the following two ways of importing are acceptable:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ProtParCon</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">msa</span><span class="p">,</span> <span class="n">aut</span><span class="p">,</span> <span class="n">mlt</span><span class="p">,</span> <span class="n">asr</span><span class="p">,</span> <span class="n">imc</span>
</pre></div>
</div>
</div>
<div class="section" id="align-multiple-sequences">
<h2>Align multiple sequences<a class="headerlink" href="#align-multiple-sequences" title="Permalink to this headline">¶</a></h2>
<p>Multiple sequence alignment (MSA) can be easily done in ProtParCon by using
function <code class="docutils literal notranslate"><span class="pre">msa()</span></code>, and this function has a common interface for all
supported MSA programs.</p>
<p>At this stage, MSA via MUSCLE, MAFFT, and Clustal (Omega) are supported.
You are only required to pass the path to the executable of any supported
MSA program and the path to a sequence file in FASTA format to function
<code class="docutils literal notranslate"><span class="pre">msa()</span></code>, ProtParCon will then take care of everything related to sequence
alignment for you.</p>
<p>The following examples assume that you have the needed MSA program installed
in your system and the path to its executable is the same as used here.
Otherwise, you need to replace the path to the executable of a MSA program
with its actual path. In our case, the executable of MUSCLE is named <cite>muscle</cite>
and it is already in the system path, so we are able to directly use <cite>muscle</cite>
as the path to the MUSCLE executable. All the examples also assume that the
sequence file used is in the current work directory and it is named <cite>seq.fa</cite>.
If this is not the case for you, you need to use either a relative or absolute
path of the files accordingly to make ProtParCon works as expected.</p>
<p>This Python session will automatically align sequences using MUSCLE and save
the alignment output to a file named <cite>seq.muscle.fasta</cite> in the same directory
of the sequence file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">msa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msa</span><span class="p">(</span><span class="s1">&#39;muscle&#39;</span><span class="p">,</span> <span class="s1">&#39;seq.fa&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The default naming rule for alignment output will be in the format of
[basename].[aligner].fasta, where basename is the filename of the sequence
file without known FASTA format file’s extension, aligner is the name of the
MSA program (figured by ProtParCon according to the MSA’s executable) in lower
case, and fasta is the file extension for FASTA file. Thus, the following
session will align sequence using MAFFT and save the alignment output to a
FASTA format file named ‘seq.mafft.fasta’:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">msa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msa</span><span class="p">(</span><span class="s1">&#39;mafft&#39;</span><span class="p">,</span> <span class="s1">&#39;seq.fa&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>And this will align the same sequence with Clustal (Omega) and save the
alignment to a FASTA file named ‘seq.clustal.fasta’:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">msa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msa</span><span class="p">(</span><span class="s1">&#39;clustal&#39;</span><span class="p">,</span> <span class="s1">&#39;seq.fa&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The above example assumes that you have system wide Clustal Omega
installed and the string clustal point to the executable of Clustal
Omega. If your Clustal Omega is not system widely installed, or the
path to its executable is not <cite>clustal</cite>, change it accordingly.</p>
</div>
<p>If you want to save the alignment output to a file using a customized name,
you can pass a filename to argument <code class="docutils literal notranslate"><span class="pre">outfile</span></code>. This session will align
sequence using MUSCLE and save the alignment output into a file named
<cite>alignment.fasta</cite> in the same directory of the sequence file (if you want
to save the alignment to a different directory, pass a relative or absolute
path accordingly):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">msa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msa</span><span class="p">(</span><span class="s1">&#39;muscle&#39;</span><span class="p">,</span> <span class="s1">&#39;seq.fa&#39;</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;alignment.fasta&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="infer-maximum-likelihood-tree">
<h2>Infer Maximum-Likelihood tree<a class="headerlink" href="#infer-maximum-likelihood-tree" title="Permalink to this headline">¶</a></h2>
<p>Infer Maximum-Likelihood (ML) tree can be easily done in ProtParCon by using
function <code class="docutils literal notranslate"><span class="pre">mlt()</span></code>. Since this function provides a common interface for
all supported ML programs, you can use this function to infer ML tree
using all supported ML programs in the same manner.</p>
<p>At this stage, ML tree inference via IQ-TREE, FastTree, RAxML, and PhyML
are supported in ProtParCon. You are only required to pass the path to the
executable of any supported MSA program and the path to an alignment file
in FASTA format to function <code class="docutils literal notranslate"><span class="pre">msa()</span></code>, ProtParCon will then take care of
everything about ML tree inference for you.</p>
<p>The following examples assume you have the needed ML program installed on
your system and the path to its executable is the same as used here.
Otherwise, you need to replace the path to the executable of a MSA program
with its actual path. In our case, the executable of IQ-TREE is named
<cite>iqtree</cite> and it is already in the system path, so we are able to directly
use <cite>iqtree</cite> as the path to the executable of IQ-TREE software. All the
examples also assume that the alignment file used is in the current work
directory and it is named <cite>msa.fa</cite>. If this is not the case for you,
you need to use either a relative or absolute path of the files accordingly
to make ProtParCon works as expected.</p>
<p>This Python session will automatically infer ML tree using IQ-TREE and save
the best ML tree to a file named <cite>msa.IQ-TREE.ML.newick</cite> in the same
directory of the multiple sequence alignment file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">mlt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mlt</span><span class="p">(</span><span class="s1">&#39;iqtree&#39;</span><span class="p">,</span> <span class="s1">&#39;msa.fa&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The default naming rule for ML tree output will be in the format of
[basename].[mlter].ML.newick, where basename is the filename of the
alignment file without known FASTA format file’s extension, mlter is
the name of the ML program (figured by ProtParCon according to the ML program’s
executable), ML denotes that the file contains a Maximum-Likelihood
tree, and newick is the file extension for NEWICK file. Thus, the following
session will infer ML tree using RAxML and save the ML tree to a file named
‘msa.RAxML.ML.newick’:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">mlt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mlt</span><span class="p">(</span><span class="s1">&#39;raxml&#39;</span><span class="p">,</span> <span class="s1">&#39;msa.fa&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">mlt()</span></code> provides a common interface for inferring ML tree, the
other two supported ML programs can also be used in the same way. This
example will infer ML tree using PjyML and save the ML tree to a file named
‘msa.PhyML.ML.newick’:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">mlt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mlt</span><span class="p">(</span><span class="s1">&#39;phyml&#39;</span><span class="p">,</span> <span class="s1">&#39;msa.fa&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>And, of course, this example will infer ML tree using FastTree and save the
ML tree to a file named ‘msa.FastTree.ML.newick’:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">mlt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mlt</span><span class="p">(</span><span class="s1">&#39;fasttree&#39;</span><span class="p">,</span> <span class="s1">&#39;msa.fa&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>If you want to save the resulted ML tree to a file using a customized
name, you can pass a filename to argument <code class="docutils literal notranslate"><span class="pre">outfile</span></code>. This session will
infer ML tree using RAxML and save the tree to a file named <cite>tree.newick</cite>
in the same directory of the alignment file (if you want to save the
ancestral states output to a different directory, pass a relative or absolute
path accordingly):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">mlt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mlt</span><span class="p">(</span><span class="s1">&#39;raxml&#39;</span><span class="p">,</span> <span class="s1">&#39;msa.fa&#39;</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;tree.newick&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Function <cite>mlt()</cite> also allows you to specify a substitution model for inferring
a ML tree. The model can be a name of empirical substitution name (e.g. JTT,
WAG, LG, …) or a name combined with a other options (e.g. JTT+G8,
LG+G8+I, WAG+G4+I+F). For example, the following example will infer ML tree
using LG model with 8 Gamma categories account for among-site rate variation
and estimated ML base frequencies of 20 amino acids via PhyML:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">mlt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mlt</span><span class="p">(</span><span class="s1">&#39;raxml&#39;</span><span class="p">,</span> <span class="s1">&#39;msa.fa&#39;</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;tree.newick&#39;</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s1">&#39;LG+G8+F&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>If you do not want to specify the modeling process via argument <cite>model</cite>, there
are four other arguments: <cite>gamma</cite>, <cite>alpha</cite>, <cite>freq</cite>, and <cite>invp</cite>, that you can
use to specify additional modeling information, such as number of discrete
Gamma categories, shape of discrete Gamma distribution, base frequencies of
20 amino acids, and proportion of invariable site. The value specified by
these arguments have high priority than the ones coming with model argument.
Therefore, the following example will do the exactly same things as the above
example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">mlt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mlt</span><span class="p">(</span><span class="s1">&#39;raxml&#39;</span><span class="p">,</span> <span class="s1">&#39;msa.fa&#39;</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;tree.newick&#39;</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s1">&#39;LG&#39;</span><span class="p">,</span>
<span class="go">        gamma=9, freq=&#39;estimate&#39;)</span>
</pre></div>
</div>
<p>You also have the option to provide a start tree and/or constraint tree to
control the way in which ML tree has been inferred via arguments <cite>start_tree</cite> and
<cite>constraint_tree</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">mlt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mlt</span><span class="p">(</span><span class="s1">&#39;raxml&#39;</span><span class="p">,</span> <span class="s1">&#39;msa.fa&#39;</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;tree.newick&#39;</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s1">&#39;LG+G8+I&#39;</span><span class="p">,</span>
<span class="go">         start_tree=&#39;/path/to/the/start/tree/file&#39;,</span>
<span class="go">         constraint_tree=&#39;/path/to/the/constraint/tree/file&#39;)</span>
</pre></div>
</div>
</div>
<div class="section" id="reconstruct-ancestral-states">
<h2>Reconstruct ancestral states<a class="headerlink" href="#reconstruct-ancestral-states" title="Permalink to this headline">¶</a></h2>
<p>Ancestral states reconstruction (ASR) can be easily done in ProtParCon by using
function <code class="docutils literal notranslate"><span class="pre">asr()</span></code>, and this function has a common interface for all supported
ASR programs.</p>
<p>At this stage, ASR via CODEML (inside PAML package), and RAxML are supported.
You are only required to pass the path to the executable of any supported ASR
program, the path to an alignment file in FASTA format, and a guide tree file
in NEWICK format to function <code class="docutils literal notranslate"><span class="pre">asr()</span></code>, ProtParCon will then take care of everything
about ancestral states reconstruction and results parsing for you.</p>
<p>The following examples asuume you have the needed ASR program installed on your
system and the path to its executable is the same as used here. Otherwise, you
need to replace the path to the executable of a ASR program with its actual
path. In our case, the executable of CODEML is named <cite>codeml</cite> and it is already
in the system path, so we are able to directly use <cite>codeml</cite> as the path to the
CODEML executable. All the examples also assume that the alignment file and the
tree file used here are in the current work directory and they are named
<cite>msa.fa</cite> and <cite>tree.newick</cite>. If this is not the case for you, you need to use
either a relative or absolute paths of these files accordingly to make ProtParCon
works as expected.</p>
<p>This Python session will automatically reconstruct ancestral states using CODEML
and save  the ancestral states output to a file named <cite>msa.codeml.tsv</cite> in the
same directory of the sequence file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">ars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">asr</span><span class="p">(</span><span class="s1">&#39;codeml&#39;</span><span class="p">,</span> <span class="s1">&#39;msa.fa&#39;</span><span class="p">,</span> <span class="s1">&#39;tree.nwick&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulted ancestral states file <cite>seq.codeml.tsv</cite> is TAB separated file, and
the first line of the file will start with ‘#TREE’ and followed by a TAB (t)
and then a NEWICK formatted tree string, the internal nodes are labeled. The
second line of the tsv file is intentionally left as a blank line and the rest
lines of the file are tab separated sequence IDs and amino acid sequences.</p>
<p>The default naming rule for ancestral states output will be in the format of
[basename].[asrer].tsv, where basename is the filename of the alignment file
without known FASTA format file’s extension, asrer is the name of the ASR
program (figured by ProtParCon according to the MSA’s executable) in lower case,
and fasta is the file extension for FASTA file. Thus, the following session
will reconstruct ancestral states using RAxML and save the ancestral states
output to a file named ‘msa.raxml.tsv’:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">asr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">asr</span><span class="p">(</span><span class="s1">&#39;raxml&#39;</span><span class="p">,</span> <span class="s1">&#39;msa.fa&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>If you want to save the ancestral states output to a file using a customized
name, you can pass the filename to argument <code class="docutils literal notranslate"><span class="pre">outfile</span></code>. This session will
reconstruct ancestral states using RAxML and save the ancestral states output
to a file named <cite>ancestors.tsv</cite> in the same directory of the alignment file
(if you want to save the ancestral states output to a different directory,
pass a relative or absolute path accordingly):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">asr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">asr</span><span class="p">(</span><span class="s1">&#39;raxml&#39;</span><span class="p">,</span> <span class="s1">&#39;msa.fa&#39;</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;ancestors.tsv&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The default reconstruction will use JTT model as substitution model, of course
you can use any supported substitution models by passing the name of the model
to argument <code class="docutils literal notranslate"><span class="pre">model</span></code>. This session will reconstruct ancestral states via
CODEML using WAG model:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">ars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">asr</span><span class="p">(</span><span class="s1">&#39;codeml&#39;</span><span class="p">,</span> <span class="s1">&#39;msa.fa&#39;</span><span class="p">,</span> <span class="s1">&#39;tree.nwick&#39;</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s1">&#39;WAG&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">asr()</span></code> function provides a common inteface for ancestral states
reconstruction, the same rule also applies to other support ASR programs,
like RAxML. Thus, this session will reconstruct ancestral states via RAxML
using ‘WAG’ model:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">ars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">asr</span><span class="p">(</span><span class="s1">&#39;codeml&#39;</span><span class="p">,</span> <span class="s1">&#39;msa.fa&#39;</span><span class="p">,</span> <span class="s1">&#39;tree.nwick&#39;</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s1">&#39;WAG&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The argument <cite>model</cite> can also pass other information for guiding state
reconstruction rather than just the name of a empirical substitution model.
If the model argument combined name and Gamma category numbers, i.e. JTT+G4,
WAG+G8, etc., a discrete Gamma model would be used to account for among-site
rate variation. If the model argument combined name and frequencies, i.e.
LG+G8+F, WAG+F, etc., a ML estimate of base freqeuencies of 20 amino acids
would be used instead of empirical values associated with the specified
substitution model. Thus, this session will reconstruct ancestral states
using LG model with 8 Gamma categories and a ML estimate of base frequencies
of 20 amino acids via RAxML:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">ars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">asr</span><span class="p">(</span><span class="s1">&#39;raxml&#39;</span><span class="p">,</span> <span class="s1">&#39;msa.fa&#39;</span><span class="p">,</span> <span class="s1">&#39;tree.nwick&#39;</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s1">&#39;LG+G8+F&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Another way for you to providing complicted modeling information is to use
these four arguments: <cite>gamma</cite>, <cite>alpha</cite>, <cite>freq</cite>, and <cite>invp</cite>, along with
argument <cite>model</cite>. Argument <cite>gamma</cite> will accept a integer of number of Gamma
category, <cite>alpha</cite> will let you specify the shape parameter of the discrete
Gamma distribution, and <cite>freq</cite> will accept either <cite>empirical</cite>
or <cite>estimate</cite> to specify how the base frequencies of 20 amino acids will be
handled. Thus, the following example will do the exactly same thing as the
above example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">ars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">asr</span><span class="p">(</span><span class="s1">&#39;raxml&#39;</span><span class="p">,</span> <span class="s1">&#39;msa.fa&#39;</span><span class="p">,</span> <span class="s1">&#39;tree.nwick&#39;</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s1">&#39;LG&#39;</span><span class="p">,</span>
<span class="go">        gamma=8, freq=&#39;estimate&#39;)</span>
</pre></div>
</div>
<p>Moreover, ProtParCon also allows you to use a customized substitution model (or
matrix) instead of the built-in empirical models in ASR programs. You can
pass the model (or matrix) file to argument <cite>model</cite>. In this case, if you
still want to provide modeling information, such as Gamma categories and
shape, base frequencies of amino acid, you are required to pass all these
information through <cite>gamma</cite>, <cite>alpha</cite>, and <cite>freq</cite>. This example shows you
how you can use a specified model (or matrix) file along with complicated
modeling information for ancestral states reconstruction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">ars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">asr</span><span class="p">(</span><span class="s1">&#39;codeml&#39;</span><span class="p">,</span> <span class="s1">&#39;msa.fa&#39;</span><span class="p">,</span> <span class="s1">&#39;tree.nwick&#39;</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s1">&#39;/path/to/my/own/model&#39;</span><span class="p">,</span>
<span class="go">        gamma=8, freq=&#39;estimate&#39;)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The model (or matrix) file needs to be in the right format required by ASR
programs, before use the model file, check the manual for your ASR
program to make sure you model file is in the right format.</p>
</div>
</div>
<div class="section" id="simulate-protein-sequences">
<h2>Simulate protein sequences<a class="headerlink" href="#simulate-protein-sequences" title="Permalink to this headline">¶</a></h2>
<p>ProtParCon supports simulate proteins sequences via <cite>EVOLVER</cite> (inside PAML package)
and Seg-Gen in Python script or interactive session using a common interface.
You are only required to provide an executable of any supported simulation
program and a phylogenetic tree (with branch lengths) to the general use
function <code class="docutils literal notranslate"><span class="pre">sim()</span></code>, ProtParCon will then take care everything about simulation for
you. The simplest example will look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sim</span><span class="p">(</span><span class="s1">&#39;evolver&#39;</span><span class="p">,</span> <span class="s1">&#39;tree.nwick&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The above code will use EVOLVER to simulate proteins sequences along the
phylogenetic tree specified in tree file <cite>tree.newick</cite>. ProtParCon will
automatically extract the number of leaf nodes that need to be simulated from the
tree file. The default simulation procedure will set the substitution model
to JTT model, the length of protein sequence to 100 amino acid sites, and the
number of datasets (or duplicates) to 100. Thus, after run the above code,
ProtParCon will simulate protein datasets and save simulated sequences to a tab
separated file. The default naming rule for simulation output will be in the
format of [simulator].simulations.tsv, where simulator is the name of the
simulation program you used (this will be figured by ProtParCon automatically).</p>
<p>The resulted simulation file is a TAB separated text file, and the first line
of the file will start with ‘#TREE’ and followed by a TAB (t) and then a
NEWICK formatted tree string, the internal nodes are labeled. The second line
of the tsv file is intentionally left as a blank line and the rest
lines of the file are blank line separated sequence blocks, in each sequence
block, each sequence takes a whole line and the sequence IDs and amino acid
sequences are separated by a TAB (‘t’).</p>
<p>The function <cite>sim()</cite> also allows you to simulate sequences under various
scenarios. For example, the following example will use Seq-Gen to simulate
200 protein datasets with the length set to 500 amino acids and substitution
model set to LG with 8 Gamma categories to account for among sites rate
variation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sim</span><span class="p">(</span><span class="s1">&#39;seqgen&#39;</span><span class="p">,</span> <span class="s1">&#39;tree.newick&#39;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
<span class="go">        model=&#39;LG&#39;, gamma=8)</span>
</pre></div>
</div>
<p>The following example will use Seq-Gen to simulate
200 protein datasets with the length and base frequencies of 20 amino acids
extracted from a multiple protein sequence alignment file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sim</span><span class="p">(</span><span class="s1">&#39;seqgen&#39;</span><span class="p">,</span> <span class="s1">&#39;tree.newick&#39;</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s1">&#39;LG&#39;</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
<span class="go">        msa=&#39;path/to/the/multiple/sequence/alignment/file&#39;,</span>
<span class="go">        freq=&#39;estimate&#39;,</span>
<span class="go">        outfile=&#39;path/to/the/simulation/output/file&#39;)</span>
</pre></div>
</div>
<p>Since you also passed a filename to argument <cite>outfile</cite>, in the above example,
simulated sequences and the labeled tree will be saved to the file you
specified.</p>
</div>
<div class="section" id="topology-test">
<h2>Topology test<a class="headerlink" href="#topology-test" title="Permalink to this headline">¶</a></h2>
<p>For our own purpose, the only topology test supported in ProtParCon at this stage
is AU test and the test need to use IQ-TREE. The test can be easily done via
function <cite>aut</cite> inside ProtParCon. For example, assume we have multiple sequence
alignment file and a hypothesis phylogenetic relationship specified in a
NEWICK tree file, we want to know how big the differences are between the
phylogenetic relationship specified by the tree file and the relationship
specified by the best ML tree given the MSA file, thus we can do the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">aut</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aut</span><span class="p">(</span><span class="s1">&#39;iqtree&#39;</span><span class="p">,</span> <span class="s1">&#39;msa.fa&#39;</span><span class="p">,</span> <span class="s1">&#39;tree.newick&#39;</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s1">&#39;WAG&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Running the above code will conduct AU test implemented in IQ-TREE program
without knowing how to use IQ-TREE.</p>
</div>
<div class="section" id="identify-molecular-convergence-in-proteins">
<h2>Identify molecular convergence in proteins<a class="headerlink" href="#identify-molecular-convergence-in-proteins" title="Permalink to this headline">¶</a></h2>
<p>The function <code class="docutils literal notranslate"><span class="pre">imc()</span></code> inside ProtParCon package provides a common and easy way to
identify parallel and convergent amino acid replacements in orthologous
proteins separately. It is able to take the following kinds of
sequence data and identify parallel and convergent amino acid replacements
for all comparable branch pairs within the phylogenetic tree:</p>
<blockquote>
<div><ul class="simple">
<li>sequences: raw protein sequence file, need to be in FASTA format
(a NEWICK format tree, a multiple sequence alignment program,
an ancestral states reconstruction program are also required.</li>
<li>msa: multiple sequence alignment file, need to be in FASTA format
(a NEWICK format tree and an ancestral states reconstruction program
are also required).</li>
<li>ancestors: reconstructed ancestral states file, need to be in tsv
(tab separated) file, the first line needs to start with #TREE,
second line need to be a blank line, and the rest lines in the
file need to be tab separated sequence name (or ID) and amino
acid sequences.</li>
<li>simulations: simulated sequences, need to be in tsv file, the
first line needs to start with #TREE, second line need to be
a blank line, each dataset need to be separated by a blank line
and inside each dataset block, each line should consist of tab
separated sequence name (or ID) and amino acid sequences.</li>
</ul>
</div></blockquote>
<p>In the simplest way, if you pass a result file generated during ancestral
states reconstruction to <cite>imc()</cite>, parallel and convergent amino acid
replacements will be identified without requiring any other information:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">imc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imc</span><span class="p">(</span><span class="s1">&#39;path/to/the/ancestral/states/file&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>After running the above code, there are two TAB separated files saved
to the current work directory: ‘imc.counts.tsv’ and ‘imc.details.tsv’. The
former file contains information about the number of parallel and convergent
amino acid replacements among branch pairs, while the later file contains
details of each identified parallel or convergent amino acid replacement.</p>
<p>If you are interested in identifying parallel and convergent amino acid
replacements in a protein orthologous group and you also want to identify
the corresponding number of parallel changes in simulated datasets
based on the protein orthologous group, you can manually do sequence
alignment, ancestral states reconstruction, sequence simulation, and identify
parallel and convergent changes step by step, or you can just let <cite>imc()</cite>
do all the work for you:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ProtParCon</span> <span class="k">import</span> <span class="n">imc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imc</span><span class="p">(</span><span class="s1">&#39;path/to/the/orthologous/file&#39;</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="s1">&#39;path/to/the/tree/file&#39;</span><span class="p">,</span>
<span class="go">        aligner=&#39;path/to/the/executable/of/a/MSA/program&#39;,</span>
<span class="go">        ancestor=&#39;path/to/the/executable/of/a/ASR/program&#39;,</span>
<span class="go">        anc_model=&#39;LG+G8+F&#39;,</span>
<span class="go">        simulator=&#39;path/to/the/executable/of/a/simulation/program&#39;,</span>
<span class="go">        sim_model=&#39;LG+G8+F&#39;,</span>
<span class="go">        wd=&#39;path/to/the/work/directory&#39;)</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="usage-shell.html" class="btn btn-neutral float-right" title="Using ProtParCon in terminal" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="install.html" class="btn btn-neutral float-left" title="Install ProtParCon" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, FEI YUAN

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>